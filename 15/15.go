// К каким негативным последствиям может привести данный фрагмент кода, и как это исправить? Приведите корректный пример реализации.

// var justString string
// func someFunc() {
//   v := createHugeString(1 << 10)
//   justString = v[:100]
// }

// func main() {
//   someFunc()
// }

/*
Заданный фрагмент кода может привести к нескольким негативным последствиям:

Неэффективное использование памяти: Функция createHugeString создает очень большой строковый объект, который затем не используется полностью. Это приводит к ненужному расходу памяти.
Сложности с управлением памятью: В Go, строки являются неизменяемыми, что означает, что при присваивании части строки другой переменной, как в данном случае, создается новая копия строки. Это может привести к значительному увеличению потребления памяти, особенно если исходная строка очень большая.
Производительность: Создание больших строковых объектов и их частое копирование может существенно замедлить выполнение программы, особенно на системах с ограниченными ресурсами.
*/

package main

import "fmt"

// createHugeString создает очень большую строку.
func createHugeString(size int) []byte {
	data := make([]byte, size)
	for i := range data {
		data[i] = byte(i % 256) // Заполнение случайными байтами для примера
	}
	return data
}

// someFunc теперь работает с срезом байтов, а не с строкой.
func someFunc() {
	v := createHugeString(1 << 20) // Создаем очень большую строку
	justBytes := v[:100]           // Извлекаем первые 100 байтов
	//Имитация работы с justBytes
	fmt.Println(justBytes)
}

func main() {
	someFunc()
}
